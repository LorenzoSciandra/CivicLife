{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nvar _Logger = require('./Logger');\nvar _Logger2 = _interopRequireDefault(_Logger);\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\n/*\n  Locates a Eureka host using static configuration. Configuration can either be\n  done using a simple host and port, or a map of serviceUrls.\n */\nvar ConfigClusterResolver = function () {\n  function ConfigClusterResolver(config, logger) {\n    _classCallCheck(this, ConfigClusterResolver);\n    this.logger = logger || new _Logger2.default();\n    this.config = config;\n    this.serviceUrls = this.buildServiceUrls();\n  }\n  ConfigClusterResolver.prototype.resolveEurekaUrl = function resolveEurekaUrl(callback) {\n    var retryAttempt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    if (this.serviceUrls.length > 1 && retryAttempt > 0) {\n      this.serviceUrls.push(this.serviceUrls.shift());\n    }\n    callback(null, this.serviceUrls[0]);\n  };\n  ConfigClusterResolver.prototype.buildServiceUrls = function buildServiceUrls() {\n    var _config$eureka = this.config.eureka,\n      host = _config$eureka.host,\n      port = _config$eureka.port,\n      servicePath = _config$eureka.servicePath,\n      ssl = _config$eureka.ssl,\n      serviceUrls = _config$eureka.serviceUrls,\n      preferSameZone = _config$eureka.preferSameZone;\n    var dataCenterInfo = this.config.instance.dataCenterInfo;\n    var metadata = dataCenterInfo ? dataCenterInfo.metadata : undefined;\n    var instanceZone = metadata ? metadata['availability-zone'] : undefined;\n    var urls = [];\n    var zones = this.getAvailabilityZones();\n    if (serviceUrls) {\n      zones.forEach(function (zone) {\n        if (serviceUrls[zone]) {\n          if (preferSameZone && instanceZone && instanceZone === zone) {\n            urls.unshift.apply(urls, serviceUrls[zone]);\n          }\n          urls.push.apply(urls, serviceUrls[zone]);\n        }\n      });\n    }\n    if (!urls.length) {\n      var protocol = ssl ? 'https' : 'http';\n      urls.push(protocol + '://' + host + ':' + port + servicePath);\n    }\n    return urls;\n  };\n  ConfigClusterResolver.prototype.getAvailabilityZones = function getAvailabilityZones() {\n    var _config$eureka2 = this.config.eureka,\n      ec2Region = _config$eureka2.ec2Region,\n      availabilityZones = _config$eureka2.availabilityZones;\n    if (ec2Region && availabilityZones && availabilityZones[ec2Region]) {\n      return availabilityZones[ec2Region];\n    }\n    return ['default'];\n  };\n  return ConfigClusterResolver;\n}();\nexports.default = ConfigClusterResolver;","map":{"version":3,"names":["exports","__esModule","_Logger","require","_Logger2","_interopRequireDefault","obj","default","_classCallCheck","instance","Constructor","TypeError","ConfigClusterResolver","config","logger","serviceUrls","buildServiceUrls","prototype","resolveEurekaUrl","callback","retryAttempt","arguments","length","undefined","push","shift","_config$eureka","eureka","host","port","servicePath","ssl","preferSameZone","dataCenterInfo","metadata","instanceZone","urls","zones","getAvailabilityZones","forEach","zone","unshift","apply","protocol","_config$eureka2","ec2Region","availabilityZones"],"sources":["/home/michelestaffieri/Documenti/Taass/CivicLife/CivicLife/frontend/node_modules/eureka-js-client/lib/ConfigClusterResolver.js"],"sourcesContent":["'use strict';\n\nexports.__esModule = true;\n\nvar _Logger = require('./Logger');\n\nvar _Logger2 = _interopRequireDefault(_Logger);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/*\n  Locates a Eureka host using static configuration. Configuration can either be\n  done using a simple host and port, or a map of serviceUrls.\n */\nvar ConfigClusterResolver = function () {\n  function ConfigClusterResolver(config, logger) {\n    _classCallCheck(this, ConfigClusterResolver);\n\n    this.logger = logger || new _Logger2.default();\n    this.config = config;\n    this.serviceUrls = this.buildServiceUrls();\n  }\n\n  ConfigClusterResolver.prototype.resolveEurekaUrl = function resolveEurekaUrl(callback) {\n    var retryAttempt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    if (this.serviceUrls.length > 1 && retryAttempt > 0) {\n      this.serviceUrls.push(this.serviceUrls.shift());\n    }\n    callback(null, this.serviceUrls[0]);\n  };\n\n  ConfigClusterResolver.prototype.buildServiceUrls = function buildServiceUrls() {\n    var _config$eureka = this.config.eureka,\n        host = _config$eureka.host,\n        port = _config$eureka.port,\n        servicePath = _config$eureka.servicePath,\n        ssl = _config$eureka.ssl,\n        serviceUrls = _config$eureka.serviceUrls,\n        preferSameZone = _config$eureka.preferSameZone;\n    var dataCenterInfo = this.config.instance.dataCenterInfo;\n\n    var metadata = dataCenterInfo ? dataCenterInfo.metadata : undefined;\n    var instanceZone = metadata ? metadata['availability-zone'] : undefined;\n    var urls = [];\n    var zones = this.getAvailabilityZones();\n    if (serviceUrls) {\n      zones.forEach(function (zone) {\n        if (serviceUrls[zone]) {\n          if (preferSameZone && instanceZone && instanceZone === zone) {\n            urls.unshift.apply(urls, serviceUrls[zone]);\n          }\n          urls.push.apply(urls, serviceUrls[zone]);\n        }\n      });\n    }\n    if (!urls.length) {\n      var protocol = ssl ? 'https' : 'http';\n      urls.push(protocol + '://' + host + ':' + port + servicePath);\n    }\n    return urls;\n  };\n\n  ConfigClusterResolver.prototype.getAvailabilityZones = function getAvailabilityZones() {\n    var _config$eureka2 = this.config.eureka,\n        ec2Region = _config$eureka2.ec2Region,\n        availabilityZones = _config$eureka2.availabilityZones;\n\n    if (ec2Region && availabilityZones && availabilityZones[ec2Region]) {\n      return availabilityZones[ec2Region];\n    }\n    return ['default'];\n  };\n\n  return ConfigClusterResolver;\n}();\n\nexports.default = ConfigClusterResolver;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}